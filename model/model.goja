model shop {

// Server relevant classes - region begin
server Server {
 	public Service service;
}

abstract server Service {
}

server OwnerService extends Service {

	//Manager
  	one-to-one (server-only myServer) ComponentManager componentManager;
	CustomerDeliveryTimeManager customerDeliveryTimeManager##cdtm;
	ProducerLst prmanager;
	Settings settings;
	one-to-one (server-only myServer) ReOrderManager reOrderManager;
	one-to-one (server-only myServer) OwnerOrderManager ownerOrderManager##oom;
	one-to-one (server-only myServer) ReturnManager returnManager##rm;


	//Producer
	void createProducer@@Hersteller_anlegen(String name) throws DoubleDefinitionException;

	//Articles
	//TODO: Prevent article creation with same name and producer
	void newArticle@@Neuer_Artikel(ProductGroup parent, String name, Fraction price, Integer minStock, Integer maxStock, Integer producerDeliveryTime, Producer producer) throws CycleException, DoubleDefinitionException;
	void newProductGroup@@Neue_Produktgruppe(ProductGroup parent, String name) throws CycleException, DoubleDefinitionException;
	void newProductGroup@@Neue_Produktgruppe(String name) throws DoubleDefinitionException, CycleException;
	
	void moveTo@@verschieben(Component component, ComponentContainer newParentGroup)throws CycleException;


	no-view void changeArticleName(ArticleWrapper article, String newName);
	no-view void changeArticlePrice(ArticleWrapper article, Fraction newPrice);

	void startSelling@@Verkauf_starten(ArticleWrapper article checked);
	void stopSelling@@Verkauf_beenden(ArticleWrapper article checked);

	no-view Article getArticle(ArticleWrapper wrapper);


	//Customer Delivery Time
	void createCustomerDeliveryTime@@Neue_Kundenlieferzeit(String name, Fraction price, Integer time) throws DoubleDefinitionException;
	no-view void changeCustomerDeliveryTimePrice(CustomerDeliveryTime customerDeliveryTime, Fraction newValue);
	no-view void changeCustomerDeliveryTimeTime(CustomerDeliveryTime customerDeliveryTime, Integer newValue);


	//Settings
	no-view void changeNewCustomerDefaultBalance(Fraction newValue );
	no-view void changeNewCustomerDefaultLimit(Fraction newValue);
	no-view void changeReturnPercentage(Fraction newValue);


	//Only for testing
	void reduceArticleStock(ArticleWrapper article, Integer quantity) throws NotEnoughStockException;
	void increaseArticleStock(ArticleWrapper article, Integer quantity);
}

server CustomerService extends Service {

	CustomerArticleLst articleLst;
  	observe ComponentManager componentManager;

	CustomerDeliveryTimeManager customerDeliveryTimeManager##cdtm;

	prior CustomerAccount account;
	ShoppingCart cart;
	observe CustomerOrderManager orderManager;

	//ShoppingCart
	void addToCart@@In_den_Warenkorb(ArticleWrapper article checked, Integer quantity@@Anzahl);
	void changeArticleQuantity@@Anzahl_ändern(ShoppingCartQuantifiedArticle article, Integer newQuantity@@Anzahl);
	void removeFromCart@@Entfernen(ShoppingCartQuantifiedArticle article);

	//Ordering
	void order@@Bestellen(ShoppingCart cart, CustomerDeliveryTime customerDeliveryTime@@Versandart) throws NotEnoughStockException, NotEnoughMoneyException, EmptyCartException;
	void preOrder@@Vorbestellen(ShoppingCart cart, CustomerDeliveryTime customerDeliveryTime@@Versandart) throws NotEnoughMoneyException, EmptyCartException;
	
	void acceptOrder@@Lieferung_annehmen(Order order);
	void markForReturn@@Als_Retour_markieren(OrderQuantifiedArticle article);
	void unmarkForReturn@@Retour_markierung_entfernen(OrderQuantifiedArticle article);

	//Money
	void deposit@@Einzahlen(Fraction amount);
	void withdraw@@Auszahlen(Fraction amount) throws NotEnoughMoneyException;

	//Search
	void findArticle@@Artikel_suchen(String name);
	void clearError(ErrorDisplay error);
	void clear();

	//Refresh
	void reloadUI();
}

server CustomerRegisterService##crs extends Service {
	active void register(String accountName, String password PASSWORD) throws UserAlreadyExistsException;
}
// Server relevant classes -- region end



// manager relevant classes -- region begin
class CustomerArticleLst##cal {
	public ArticleWrapper ** articles;
	
	void find(String name);
	void clear();
}

singleton ProducerLst {
	public Producer ** currentProducer##currProd;
	active Producer createProducer(String name) throws DoubleDefinitionException;
}

singleton CustomerDeliveryTimeManager##cdtm {
	public CustomerDeliveryTime ** customerDeliveryTimes##cdts;
	active CustomerDeliveryTime createCustomerDeliveryTime##ccdt(String name, Fraction price, Integer time) throws DoubleDefinitionException;
}

singleton Settings{
	public-write Fraction newCustomerDefaultBalance##ncdb;
	public-write Fraction newCustomerDefaultLimit##ncdlOwn;
	public-write Fraction returnPercentage;
}

singleton ReOrderManager covers BackgroundTask{
	ReOrderQuantifiedArticle ** reorderArticles;

	//Reorders enough aricles to get back to maxStock
	active void reOrder(ArticleWrapper article);

	//Reorders <<quantity>> amount of articles (used for preorders only)
	active void reOrderForPreorder##rofp(ArticleWrapper article, Integer quantity);
}

abstract class OrderManager{
	public observe Order ** orders;
}

class CustomerOrderManager##com extends OrderManager{
	prior no-view CustomerAccount account;

	active void newOrder(ShoppingCart cart, CustomerDeliveryTime customerDeliveryTime) throws NotEnoughStockException, NotEnoughMoneyException, EmptyCartException;
	active void newPreOrder(ShoppingCart cart, CustomerDeliveryTime customerDeliveryTime) throws NotEnoughMoneyException, EmptyCartException;

	//Accepts the order. OrderQuantifiedArticles in the OrderQuantifiedArticleMarkedForReturnState will get returned.
	active void acceptOrder(Order order) throws NotEnoughMoneyException, OrderNotYetArrivedException;
}

singleton BackgroundTaskManager##btm{

	BackgroundTask ** tasks;
	void addTask(BackgroundTask task);
	void startTasks();
	void stopTasks();
	event void step();
}

abstract class BackgroundTask{
	void startTask(Integer tickTime);
	void stopTask();
	abstract event void step();
}

singleton OwnerOrderManager##oom extends OrderManager covers BackgroundTask{
	void addOrder(Order order);
}

singleton ReturnManager{
	public ArticleReturn ** articleReturn;
	active void addArticleReturn##aar(ArticleReturn articleReturn);
	
}
// manager relevant classes -- region end

// main model classes -- region begin

hierarchy collapsed CompHierarchy;


singleton ComponentManager implements ComponentContainer{
	public Component ** components hierarchy CompHierarchy;
}

abstract class Component{
	prior no-view ComponentContainer parent;
	active event void moveTo(ComponentContainer container) throws CycleException;
}

interface ComponentContainer{
 
   event	void removeComponent(Component component);
	event	void addComponent(Component component) throws CycleException;

	active event ProductGroup newProductGroup##cspg(String name) throws CycleException, DoubleDefinitionException;
	active event ArticleWrapper newArticle(String name, Fraction price, Integer minStock, Integer maxStock, Integer producerDeliveryTime, Producer producer) throws CycleException;

}

class ProductGroup extends Component implements ComponentContainer{
	public Component ** components hierarchy CompHierarchy;
	public-write prior indexed String name@@Name;

}

class ArticleWrapper extends Component{
   public prior server-only Article article;

	derived Fraction price@@Preis;
	derived String name@@Name;
}

class Article{
	public-write prior indexed String name@@Name;

	public-write prior Fraction price@@Preis;
	public-write prior Integer minStock@@Mindestlagerbestand;
	public-write prior Integer maxStock@@Maximallagerbestand;
	public-write Integer currentStock@@Lagerbestand;
	public-write prior Integer producerDeliveryTime@@Herstellerlieferzeit;

	public-write no-view prior Producer producer;
	public-write no-view ArticleState state;

	derived String currentState@@Status;
	derived String producerName@@Hersteller;

	active event void reduceStock(Integer quantity) throws NotEnoughStockException;
	active event void increaseStock(Integer quantity);

	active event void startSelling();
	active event void stopSelling();
}



// Article States -- region begin

abstract class ArticleState{
}

class NewCreated extends ArticleState{
}
class InSale extends ArticleState{
}
class RemainingStock extends ArticleState{
}
class NotInSale extends ArticleState{
}

// Article States -- region end




abstract class QuantifiedArticle{
	prior public Integer quantity;
	prior public no-view ArticleWrapper article;

	void increaseQuantity(Integer amount);
}

class ShoppingCartQuantifiedArticle##scqa extends QuantifiedArticle{
	active void changeArticleQuantity##caq(Integer newQuantity);
}

class OrderQuantifiedArticle##oqa extends QuantifiedArticle{
	prior public Fraction articlePriceAtOrderTime##apatot;
	public no-view OrderQuantifiedArticleState state;
	void markForReturn();
	void unmarkForReturn();

}

abstract class OrderQuantifiedArticleState##ooas{
}
class OrderQuantifiedArticleNormalState##ooans extends OrderQuantifiedArticleState{
}

class OrderQuantifiedArticleMarkedForReturnState##ooamafrs extends OrderQuantifiedArticleState{
}




class ReturnQuantifiedArticle##rqa extends QuantifiedArticle{

}

class ReOrderQuantifiedArticle##roqa extends QuantifiedArticle{
	Integer producerDeliveryTimeAtReorder##pdtar;
	public-write Integer countdown;
}

class Producer{
	public prior indexed String name;
}

class CustomerAccount{
	public prior indexed String name;
	public-write prior Fraction balance;
	public prior Fraction limit;
	ShoppingCart shoppingCart;

	active void deposit(Fraction amount);
	active void withdraw(Fraction amount) throws NotEnoughMoneyException;	

	active void debit(Fraction amount) throws NotEnoughMoneyException;	

}


class CustomerDeliveryTime{
	prior public String name;
	prior public-write Fraction price;
	prior public-write Integer deliveryTime;
}

class ShoppingCart{
	public ShoppingCartQuantifiedArticle ** articles;

	active void addArticle(ShoppingCartQuantifiedArticle article);
	active void removeArticle(ShoppingCartQuantifiedArticle article);
}

class Order{
	public OrderQuantifiedArticle ** articles;
	prior public CustomerDeliveryTime customerDeliveryTime;
	void addArticle(OrderQuantifiedArticle orderQuantifiedArticle);

	public-write Fraction totalPrice;
	
	prior public-write OrderStatus state;
}

class ArticleReturn{
	prior	one-to-one (myOrder) Order order;
	public ReturnQuantifiedArticle ** returnArticles;
	void addArticle(ReturnQuantifiedArticle orderQuantifiedArticle);


}

abstract class OrderStatus{
}

class ProcessingOrderState##pos extends OrderStatus{
}
class InTransitOrderState##itos extends OrderStatus{
	public-write prior Integer ticksLeft;
}

class PreOrderState extends OrderStatus{
}
class WaitingForAcceptOrderState##wfao extends OrderStatus{
	public-write prior Integer ticksLeft;
}
class ArticlesInReturnOrderState##airos extends OrderStatus{
	public-write prior Integer ticksLeft;
}


class FinishedOrderState##fos extends OrderStatus{
}


// main model classes -- region end

exception DoubleDefinitionException{}
exception UserAlreadyExistsException{}

exception NotEnoughStockException{}
exception NotEnoughMoneyException{}
exception EmptyCartException{}
exception OrderNotYetArrivedException{}
}
